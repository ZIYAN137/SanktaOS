# 同步机制设计要点

## 概述

本文档记录 SanktaOS 在同步与并发方面的关键设计要点，主要覆盖：

- SMP（多核）场景下的并发来源与处理原则
- 中断上下文的限制与建议
- 锁顺序（lock ordering）与死锁预防的通用规则

具体 API 细节以源码 rustdoc 为准：

- `crates/sync/src/`：通用同步原语（SpinLock/RwLock/TicketLock/IntrGuard/PreemptGuard 等）
- `os/src/sync/`：与内核运行时强相关的同步封装（如 `PerCpu`、内核互斥等）

## SMP 下的并发来源

在单核系统中，“任务代码 vs 本地中断处理”是最常见的并发来源；禁用本地中断可避免被中断打断。

在 SMP 系统中，并发来源更复杂：

- 任务 vs 任务：不同 CPU 上的任务并行执行访问共享数据
- 任务 vs 中断：某 CPU 上任务运行的同时，另一 CPU 上中断处理也可能访问同一共享数据
- 中断 vs 中断：多个 CPU 上的中断处理并行访问共享状态（例如驱动共享结构）
- IPI 协议：跨核同步（例如 TLB shootdown）需要发送方与接收方之间的协议保证一致性

结论：

- 仅靠“禁用本地中断”不足以保证多核安全；跨核共享数据必须使用自旋锁/原子/其他同步手段。
- 中断处理应尽量短小，把耗时工作下放到任务上下文执行（例如工作队列/延迟任务）。

## 中断上下文的锁使用限制

中断处理程序（包括 IPI）通常不能被调度、不能睡眠，因此存在天然限制：

- 禁止使用任何可能阻塞/睡眠的同步原语或路径
- 避免在中断上下文中做可能触发内存分配、复杂 I/O 的操作
- 允许使用的同步方式应以“短临界区自旋锁 + 必要的本地中断保护”为主

如果需要在中断中触发较重的处理流程，建议只完成：

- 读取/应答硬件中断
- 记录必要的状态并唤醒下半部执行（任务上下文）

## 锁顺序与死锁预防（通用规则）

死锁的典型成因是循环等待：不同执行流以不同顺序获取多把锁，导致互相等待。

最常用的预防方法是“资源排序（lock ordering）”：

- 为系统中的锁定义一个全局的获取顺序（从高层到低层）
- 任何时候需要同时获取多把锁，都必须遵循该顺序
- 严禁持有低层级锁时再去获取更高层级锁（避免形成环）

建议的经验顺序（从“更全局/更粗粒度”到“更局部/更细粒度”）：

1. 全局管理器类锁（例如全局表、全局队列）
2. 调度/等待队列相关锁（涉及任务状态切换）
3. CPU 本地状态锁
4. 单个任务/对象实例锁
5. 对象内部子字段锁

## 锁顺序与死锁预防（项目常见锁层级）

上面的顺序是“经验规则”。在内核代码里，为了让规则可执行、可落地，我们额外给出一份**常见锁**的参考层级表（从高到低）。

注意：

- 这不是“完整枚举”，而是覆盖最常见的 `Task/WaitQueue/Scheduler` 相关路径。
- 当前调度器是 **per-CPU** 的 `current_scheduler()` / `scheduler_of()`（不是单一全局 `SCHEDULER`）。
- CPU 本地状态本身不是“锁”，但访问 `current_cpu()` 需要通过 `PreemptGuard` 保证不发生任务迁移；如果同时需要“禁抢占 + 多把锁”，通常建议先进入 `PreemptGuard`，再按锁顺序获取其它锁。

| 层级（高→低） | 锁（示例） | 保护对象 / 备注 |
|---|---|---|
| 1 | `TASK_MANAGER`（全局 `SpinLock`） | 全局任务表、TID 分配、跨进程/跨任务查找等 |
| 2 | `WaitQueue` 相关锁（外层 `SpinLock<WaitQueue>`，以及内部 `WaitQueue.lock: RawSpinLock`） | 等待队列的 sleep/wake；**唤醒路径可能进入调度器** |
| 3 | 调度器锁（`current_scheduler()` / `scheduler_of()` 的 `SpinLock`） | per-CPU runqueue；与任务状态切换强相关 |
| 4 | 单个任务实例锁（`task.lock()` / `SpinLock<TaskStruct>`） | 任务状态、上下文、资源引用等；常出现在唤醒/切换路径中 |
| 5 | 任务内部字段锁（例如 `children`、`wait_child` 等） | 更细粒度的共享字段；应尽量放在最后获取 |

强约束（推荐写成“硬规则”去遵守）：

- 不要在持有“低层级锁”（例如 `task.lock()`、任务字段锁）时再去获取“高层级锁”（例如 `TASK_MANAGER`）。
- `WaitQueue` 的 `wake_up_*` / `sleep_*` 可能触达调度器与任务状态，尽量避免在持有调度器锁时调用等待队列操作，除非你非常清楚其锁链。

可参考的真实锁链（源码里已有注释解释其安全性）：

- `os/src/kernel/task/mod.rs` 中 `notify_parent()` 的注释对典型路径做了锁链拆解（涉及 `TASK_MANAGER`、父任务锁、`wait_child`、调度器与父任务再次加锁）。

额外建议：

- 尽量缩短持有“全局锁”的时间
- 避免在持有自旋锁时调用可能再次获取锁的复杂路径（尤其是隐式分配/日志等）
- 需要嵌套锁时，优先通过封装（API 约束）让调用者很难写出逆序代码
