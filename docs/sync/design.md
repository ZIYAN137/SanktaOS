# 同步机制设计要点

## 概述

本文档记录 SanktaOS 在同步与并发方面的关键设计要点，主要覆盖：

- SMP（多核）场景下的并发来源与处理原则
- 中断上下文的限制与建议
- 锁顺序（lock ordering）与死锁预防的通用规则

具体 API 细节以源码 rustdoc 为准：

- `crates/sync/src/`：通用同步原语（SpinLock/RwLock/TicketLock/IntrGuard/PreemptGuard 等）
- `os/src/sync/`：与内核运行时强相关的同步封装（如 `PerCpu`、内核互斥等）

## SMP 下的并发来源

在单核系统中，“任务代码 vs 本地中断处理”是最常见的并发来源；禁用本地中断可避免被中断打断。

在 SMP 系统中，并发来源更复杂：

- 任务 vs 任务：不同 CPU 上的任务并行执行访问共享数据
- 任务 vs 中断：某 CPU 上任务运行的同时，另一 CPU 上中断处理也可能访问同一共享数据
- 中断 vs 中断：多个 CPU 上的中断处理并行访问共享状态（例如驱动共享结构）
- IPI 协议：跨核同步（例如 TLB shootdown）需要发送方与接收方之间的协议保证一致性

结论：

- 仅靠“禁用本地中断”不足以保证多核安全；跨核共享数据必须使用自旋锁/原子/其他同步手段。
- 中断处理应尽量短小，把耗时工作下放到任务上下文执行（例如工作队列/延迟任务）。

## 中断上下文的锁使用限制

中断处理程序（包括 IPI）通常不能被调度、不能睡眠，因此存在天然限制：

- 禁止使用任何可能阻塞/睡眠的同步原语或路径
- 避免在中断上下文中做可能触发内存分配、复杂 I/O 的操作
- 允许使用的同步方式应以“短临界区自旋锁 + 必要的本地中断保护”为主

如果需要在中断中触发较重的处理流程，建议只完成：

- 读取/应答硬件中断
- 记录必要的状态并唤醒下半部执行（任务上下文）

## 锁顺序与死锁预防（通用规则）

死锁的典型成因是循环等待：不同执行流以不同顺序获取多把锁，导致互相等待。

最常用的预防方法是“资源排序（lock ordering）”：

- 为系统中的锁定义一个全局的获取顺序（从高层到低层）
- 任何时候需要同时获取多把锁，都必须遵循该顺序
- 严禁持有低层级锁时再去获取更高层级锁（避免形成环）

建议的经验顺序（从“更全局/更粗粒度”到“更局部/更细粒度”）：

1. 全局管理器类锁（例如全局表、全局队列）
2. 调度/等待队列相关锁（涉及任务状态切换）
3. CPU 本地状态锁
4. 单个任务/对象实例锁
5. 对象内部子字段锁

额外建议：

- 尽量缩短持有“全局锁”的时间
- 避免在持有自旋锁时调用可能再次获取锁的复杂路径（尤其是隐式分配/日志等）
- 需要嵌套锁时，优先通过封装（API 约束）让调用者很难写出逆序代码

