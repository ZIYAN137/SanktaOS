DOCKER_TAG ?= comix:latest

# 架构选择: riscv (默认) 或 loongarch
ARCH ?= riscv
# 启用 oscomp 特性（1/0）
OSCOMP ?= 0

# ============================================================
# OSCOMP submission targets (root Makefile)
# ============================================================
#
# The OS-competition judge will run `make all` at repo root and expects:
#   - ELF kernels: kernel-rv, kernel-la
#   - optional rootfs disks: disk.img, disk-la.img
#
# Note: the judge filters hidden files/dirs on clone; in particular `os/.cargo`
# is removed. We recreate `os/.cargo/config.toml` during the build.
#
RV_TARGET := riscv64gc-unknown-none-elf
LA_TARGET := loongarch64-unknown-none
OS_DIR := os
OS_BIN := os
# Per-test timeout (seconds) for OSCOMP runner.
# 0 = disabled.
#
# NOTE: For local debugging you may want 0. For submission, a non-zero timeout
# can help avoid "评测时间过长" if a test hangs.
OSCOMP_TEST_TIMEOUT_SECS ?= 0

# 可选特性开关
FEATURE_FLAGS :=
ifeq ($(OSCOMP),1)
    FEATURE_FLAGS := --features oscomp
endif

# 根据架构设置 target 和运行命令
ifeq ($(ARCH),loongarch)
    TARGET := loongarch64-unknown-none
    TARGET_DIR := target/loongarch64-unknown-none/debug
    PROJECT_DIR := $(TARGET_DIR)/os
    RUN_SCRIPT := cargo run --target $(TARGET) $(FEATURE_FLAGS)
    GDB_SCRIPT := cargo run --target $(TARGET) $(FEATURE_FLAGS) -- gdb
else
    TARGET := riscv64gc-unknown-none-elf
    RUN_SCRIPT := cargo run $(FEATURE_FLAGS)
    GDB_SCRIPT := cargo run $(FEATURE_FLAGS) -- --gdb
endif

.PHONY: docker build_docker fmt run build clean clean-all
.PHONY: debug gdb gdb-local
.PHONY: debug-oscomp-rv gdb-oscomp-rv debug-oscomp-la gdb-oscomp-la
.PHONY: all kernel-rv kernel-la disk.img disk-la.img os-cargo-config
.PHONY: prepare-testimg prepare-testimg-rv prepare-testimg-la
.PHONY: unxz-testimg run-oscomp-rv run-oscomp-la

docker:
	docker run --rm -it -v ${PWD}:/mnt -w /mnt --name comix ${DOCKER_TAG} bash

build_docker:
	docker build -t ${DOCKER_TAG} --target build .

fmt:
	cd os && cargo fmt --all

# 构建内核（build.rs 会自动编译 user 并打包镜像）
build:
	cd os && cargo build --target $(TARGET) $(FEATURE_FLAGS)

# 运行内核（build.rs 会自动编译 user 并打包镜像）
run:
	cd os && $(RUN_SCRIPT)

# Two-terminal debug flow (reference: os/Makefile):
# - Terminal A: `make debug ...` starts QEMU and waits for gdb.
# - Terminal B: `make gdb ...` connects to QEMU's gdbstub.
#
# Non-OSCOMP: delegate to os/Makefile.
debug:
ifeq ($(OSCOMP),1)
ifeq ($(ARCH),loongarch)
	@$(MAKE) debug-oscomp-la
else
	@$(MAKE) debug-oscomp-rv
endif
else
	@$(MAKE) -C os debug ARCH=$(ARCH)
endif

gdb:
ifeq ($(OSCOMP),1)
ifeq ($(ARCH),loongarch)
	@$(MAKE) gdb-oscomp-la
else
	@$(MAKE) gdb-oscomp-rv
endif
else
	@$(MAKE) -C os gdb ARCH=$(ARCH)
endif

# Keep the old single-terminal gdb entry for convenience.
gdb-local:
	cd os && $(GDB_SCRIPT)

# ============================================================
# OSCOMP judge entrypoint
# ============================================================

# Recreate `os/.cargo/config.toml` because hidden directories are filtered by the judge.
os-cargo-config:
	@mkdir -p $(OS_DIR)/.cargo
	@printf '%s\n' \
		'[unstable]' \
		'build-std = ["core", "compiler_builtins", "alloc"]' \
		'build-std-features = ["compiler-builtins-mem"]' \
		'' \
		'[target.riscv64gc-unknown-none-elf]' \
		'rustflags = ["-Clink-arg=-Tsrc/linker.ld", "-Cforce-frame-pointers=yes"]' \
		'' \
		'[target.loongarch64-unknown-none]' \
		'rustflags = ["-Clink-arg=-Tsrc/loongarch_linker.ld", "-Cforce-frame-pointers=yes"]' \
		> $(OS_DIR)/.cargo/config.toml

# The judge will run `make all` with no extra variables; force OSCOMP mode here.
all: os-cargo-config kernel-rv kernel-la disk.img disk-la.img

kernel-rv: os-cargo-config
	@echo "[OSCOMP] Building RISC-V kernel (ELF): kernel-rv"
	@cd $(OS_DIR) && OSCOMP_TEST_TIMEOUT_SECS=$(OSCOMP_TEST_TIMEOUT_SECS) cargo build --release --target $(RV_TARGET) --features oscomp
	@cp -f $(OS_DIR)/target/$(RV_TARGET)/release/$(OS_BIN) kernel-rv

kernel-la: os-cargo-config
	@echo "[OSCOMP] Building LoongArch kernel (ELF): kernel-la"
	@cd $(OS_DIR) && OSCOMP_TEST_TIMEOUT_SECS=$(OSCOMP_TEST_TIMEOUT_SECS) cargo build --release --target $(LA_TARGET) --features oscomp
	@cp -f $(OS_DIR)/target/$(LA_TARGET)/release/$(OS_BIN) kernel-la

# Rootfs images are generated by `os/build.rs` during the corresponding kernel build.
disk.img: kernel-rv
	@echo "[OSCOMP] Producing rootfs image: disk.img"
	@test -f $(OS_DIR)/fs-riscv.img
	@if [ "$(DISK_LINK)" = "1" ]; then \
		echo "[OSCOMP] Linking disk.img -> $(OS_DIR)/fs-riscv.img (local fast path; do NOT use for submission)"; \
		ln -sfn "$(OS_DIR)/fs-riscv.img" disk.img; \
	elif [ -f disk.img ] && [ ! "$(OS_DIR)/fs-riscv.img" -nt disk.img ]; then \
		echo "[OSCOMP] disk.img is up to date"; \
	else \
		cp -f "$(OS_DIR)/fs-riscv.img" disk.img; \
	fi

disk-la.img: kernel-la
	@echo "[OSCOMP] Producing rootfs image: disk-la.img"
	@test -f $(OS_DIR)/fs-loongarch.img
	@if [ "$(DISK_LINK)" = "1" ]; then \
		echo "[OSCOMP] Linking disk-la.img -> $(OS_DIR)/fs-loongarch.img (local fast path; do NOT use for submission)"; \
		ln -sfn "$(OS_DIR)/fs-loongarch.img" disk-la.img; \
	elif [ -f disk-la.img ] && [ ! "$(OS_DIR)/fs-loongarch.img" -nt disk-la.img ]; then \
		echo "[OSCOMP] disk-la.img is up to date"; \
	else \
		cp -f "$(OS_DIR)/fs-loongarch.img" disk-la.img; \
	fi

# ============================================================
# Local: fetch official test-suite SD-card images (optional)
# ============================================================
#
# You can provide the images manually (recommended for offline/CI environments):
#   - $(TESTIMG_DIR)/sdcard-rv.img     (or .img.xz)
#   - $(TESTIMG_DIR)/sdcard-la.img     (or .img.xz)
#
TESTIMG_DIR ?= test-images
TESTIMG_RV_XZ := $(TESTIMG_DIR)/sdcard-rv.img.xz
TESTIMG_LA_XZ := $(TESTIMG_DIR)/sdcard-la.img.xz
TESTIMG_RV_IMG := $(TESTIMG_DIR)/sdcard-rv.img
TESTIMG_LA_IMG := $(TESTIMG_DIR)/sdcard-la.img

prepare-testimg: prepare-testimg-rv prepare-testimg-la
	@echo "[OSCOMP] Test images ready:"
	@echo "  - $(TESTIMG_RV_IMG)"
	@echo "  - $(TESTIMG_LA_IMG)"

prepare-testimg-rv:
	@mkdir -p $(TESTIMG_DIR)
	@test -f "$(TESTIMG_RV_IMG)" || ( \
		echo "[OSCOMP] Missing RISC-V test image: $(TESTIMG_RV_IMG)"; \
		echo "[OSCOMP] (If you only have $(TESTIMG_RV_XZ), decompress it to .img first.)"; \
		exit 1; \
	)
	@echo "[OSCOMP] Found RISC-V test image: $(TESTIMG_RV_IMG)"

prepare-testimg-la:
	@mkdir -p $(TESTIMG_DIR)
	@test -f "$(TESTIMG_LA_IMG)" || ( \
		echo "[OSCOMP] Missing LoongArch test image: $(TESTIMG_LA_IMG)"; \
		echo "[OSCOMP] (If you only have $(TESTIMG_LA_XZ), decompress it to .img first.)"; \
		exit 1; \
	)
	@echo "[OSCOMP] Found LoongArch test image: $(TESTIMG_LA_IMG)"

# Optional helper: decompress *.xz into *.img.
unxz-testimg:
	@mkdir -p $(TESTIMG_DIR)
	@command -v xz >/dev/null || (echo "xz is required" && exit 1)
	@test -f "$(TESTIMG_RV_XZ)" || (echo "[OSCOMP] Missing: $(TESTIMG_RV_XZ)" && exit 1)
	@test -f "$(TESTIMG_LA_XZ)" || (echo "[OSCOMP] Missing: $(TESTIMG_LA_XZ)" && exit 1)
	@echo "[OSCOMP] Decompressing: $(TESTIMG_RV_XZ) -> $(TESTIMG_RV_IMG)"
	@xz -dkf "$(TESTIMG_RV_XZ)"
	@echo "[OSCOMP] Decompressing: $(TESTIMG_LA_XZ) -> $(TESTIMG_LA_IMG)"
	@xz -dkf "$(TESTIMG_LA_XZ)"

# Convenience targets to run with the official test images.
OSCOMP_RV_MEM ?= 1G
OSCOMP_RV_SMP ?= 1
run-oscomp-rv: kernel-rv disk.img prepare-testimg-rv
	@echo "[OSCOMP] Running RISC-V QEMU with official test image"
	qemu-system-riscv64 -machine virt -kernel kernel-rv -m $(OSCOMP_RV_MEM) -nographic -smp $(OSCOMP_RV_SMP) -bios default \
		-drive file=$(TESTIMG_RV_IMG),if=none,format=raw,id=x0 \
		-device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -no-reboot \
		-device virtio-net-device,netdev=net -netdev user,id=net -rtc base=utc \
		-drive file=disk.img,if=none,format=raw,id=x1 \
		-device virtio-blk-device,drive=x1,bus=virtio-mmio-bus.1

OSCOMP_GDB_PORT ?= 1234

# Terminal A (OSCOMP): start QEMU paused and wait for gdb.
debug-oscomp-rv: os-cargo-config prepare-testimg-rv
	@echo "[OSCOMP][DBG] Building debug kernel (riscv) with --features oscomp"
	@cd $(OS_DIR) && cargo build --target $(RV_TARGET) --features oscomp
	@echo "======================================================="
	@echo "Terminal B: run 'make gdb ARCH=riscv OSCOMP=1' to attach"
	@echo "QEMU is waiting for gdb on tcp:$(OSCOMP_GDB_PORT)"
	@echo "======================================================="
	qemu-system-riscv64 -machine virt -kernel $(OS_DIR)/target/$(RV_TARGET)/debug/$(OS_BIN) -m $(OSCOMP_RV_MEM) -nographic -smp $(OSCOMP_RV_SMP) -bios default \
		-drive file=$(TESTIMG_RV_IMG),if=none,format=raw,id=x0 \
		-device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -no-reboot \
		-device virtio-net-device,netdev=net -netdev user,id=net -rtc base=utc \
		-drive file=$(OS_DIR)/fs-riscv.img,if=none,format=raw,id=x1 \
		-device virtio-blk-device,drive=x1,bus=virtio-mmio-bus.1 \
		-S -gdb tcp::$(OSCOMP_GDB_PORT)

# Terminal B (OSCOMP): connect gdb to the paused QEMU.
gdb-oscomp-rv:
	@GDB_BIN=$$(command -v gdb-multiarch || command -v riscv64-unknown-elf-gdb || true); \
	if [ -z "$$GDB_BIN" ]; then echo "missing gdb (need gdb-multiarch or riscv64-unknown-elf-gdb)"; exit 1; fi; \
	$$GDB_BIN $(OS_DIR)/target/$(RV_TARGET)/debug/$(OS_BIN) \
		-ex "set pagination off" \
		-ex "set confirm off" \
		-ex "set arch riscv:rv64" \
		-ex "target remote :$(OSCOMP_GDB_PORT)" \
		-ex "b sys_execve" \
		-ex "b do_execve_prepare"

OSCOMP_LA_MEM ?= 2G
OSCOMP_LA_SMP ?= 1
run-oscomp-la: kernel-la disk-la.img prepare-testimg-la
	@echo "[OSCOMP] Running LoongArch QEMU with official test image"
	qemu-system-loongarch64 -kernel kernel-la -m $(OSCOMP_LA_MEM) -nographic -smp $(OSCOMP_LA_SMP) -no-reboot -rtc base=utc \
		-drive file=$(TESTIMG_LA_IMG),if=none,format=raw,id=x0 \
		-device virtio-blk-pci,drive=x0 \
		-device virtio-net-pci,netdev=net0 \
		-netdev user,id=net0,hostfwd=tcp::5555-:5555,hostfwd=udp::5555-:5555 \
		-drive file=disk-la.img,if=none,format=raw,id=x1 \
		-device virtio-blk-pci,drive=x1

# Terminal A (OSCOMP): start QEMU paused and wait for gdb.
debug-oscomp-la: os-cargo-config prepare-testimg-la
	@echo "[OSCOMP][DBG] Building debug kernel (loongarch) with --features oscomp"
	@cd $(OS_DIR) && cargo build --target $(LA_TARGET) --features oscomp
	@echo "======================================================="
	@echo "Terminal B: run 'make gdb ARCH=loongarch OSCOMP=1' to attach"
	@echo "QEMU is waiting for gdb on tcp:$(OSCOMP_GDB_PORT)"
	@echo "======================================================="
	qemu-system-loongarch64 -kernel $(OS_DIR)/target/$(LA_TARGET)/debug/$(OS_BIN) -m $(OSCOMP_LA_MEM) -nographic -smp $(OSCOMP_LA_SMP) -no-reboot -rtc base=utc \
		-drive file=$(TESTIMG_LA_IMG),if=none,format=raw,id=x0 \
		-device virtio-blk-pci,drive=x0 \
		-device virtio-net-pci,netdev=net0 \
		-netdev user,id=net0,hostfwd=tcp::5555-:5555,hostfwd=udp::5555-:5555 \
		-drive file=$(OS_DIR)/fs-loongarch.img,if=none,format=raw,id=x1 \
		-device virtio-blk-pci,drive=x1 \
		-S -gdb tcp::$(OSCOMP_GDB_PORT)

# Terminal B (OSCOMP): connect gdb to the paused QEMU.
gdb-oscomp-la:
	@GDB_BIN=$$(command -v gdb-multiarch || true); \
	if [ -z "$$GDB_BIN" ]; then echo "missing gdb-multiarch"; exit 1; fi; \
	$$GDB_BIN $(OS_DIR)/target/$(LA_TARGET)/debug/$(OS_BIN) \
		-ex "set pagination off" \
		-ex "set confirm off" \
		-ex "target remote :$(OSCOMP_GDB_PORT)" \
		-ex "b sys_execve" \
		-ex "b do_execve_prepare"

# 清理 OS 构建产物
clean:
	cd os && cargo clean

# 清理所有构建产物（包括 user）
clean-all: clean
	cd user && make clean

# 手动编译用户程序（通常不需要，build.rs 会自动处理）
build-user:
	cd user && make

# 帮助信息
help:
	@echo "ComixOS Makefile"
	@echo ""
	@echo "Usage: make [target] ARCH=[riscv|loongarch]"
	@echo ""
	@echo "Architectures:"
	@echo "  riscv      - RISC-V 64-bit (default)"
	@echo "  loongarch  - LoongArch 64-bit"
	@echo ""
	@echo "Targets:"
	@echo "  build      - Build the kernel"
	@echo "  run        - Run the kernel in QEMU"
	@echo "  gdb        - Run with GDB debugging"
	@echo "  clean      - Clean build artifacts"
	@echo "  help       - Show this help message"
	@echo ""
	@echo "Examples:"
	@echo "  make build                    # Build for RISC-V"
	@echo "  make build ARCH=loongarch     # Build for LoongArch"
	@echo "  make run ARCH=loongarch       # Run LoongArch kernel"
