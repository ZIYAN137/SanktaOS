#!/bin/sh
#
# Minimal System Initialization Script for BusyBox

# 打印信息，确认脚本已启动
echo "--- Starting Minimal BusyBox System ---"

# --- 1. 挂载伪文件系统 ---
# procfs: 进程信息
/bin/mount -t proc none /proc
# sysfs: 内核设备信息
/bin/mount -t sysfs none /sys
# tmpfs/devtmpfs: 临时文件系统和设备文件
/bin/mount -t tmpfs none /tmp
# /dev: 设备节点
# 说明：即使内核已经提前挂载 /dev，这里再次 mount 也不会影响后续流程；
# 且内核对 mount("/dev") 做了特殊处理：会在挂载 tmpfs 后自动 init_dev() 重建设备节点。
/bin/mount -t tmpfs none /dev

# --- 2. 处理设备文件 ---
# mdev 是 BusyBox 中用于创建设备文件 (/dev/null, /dev/console 等) 的工具
# -s 选项扫描 /sys/class 和 /sys/block 并创建相应的设备文件

# 现在转为由mount中进行特判，自动创建设备文件
# echo "Populating /dev via mdev..."
# /sbin/mdev -s

# --- 3. 系统配置 ---

# 设置默认主机名
DEFAULT_HOSTNAME="comix"

# 检查 /etc/hostname 文件是否存在
if [ -f /etc/hostname ]; then
    # 如果文件存在，从文件中读取并设置主机名
    /bin/hostname -F /etc/hostname
    echo "Hostname set from /etc/hostname."
else
    # 如果文件不存在，使用默认值 comix 设置主机名
    /bin/hostname "$DEFAULT_HOSTNAME"
    echo "Warning: /etc/hostname not found. Hostname set to default: $DEFAULT_HOSTNAME"
fi

# 执行 /etc/fstab 中定义的挂载
echo "Mounting file systems via fstab..."
/bin/mount -a

# 启动日志服务 (可选，如果配置了 syslogd)
# /sbin/syslogd
# /sbin/klogd

echo "System initialization finished."

run_oscomp_tests_if_present() {
    # OSCOMP test image is mounted at /tests by the kernel (init_oscomp_filesystems()).
    # If we detect official test scripts, run them non-interactively and power off.
    [ -d /tests ] || return 1

    # The official test binaries hard-code the ELF interpreter path (e.g. /lib/ld-linux-*.so.*).
    # Our rootfs is musl-based, so make glibc's loader/libs from the test image visible in /lib.
    if [ -d /tests/glibc/lib ]; then
        [ -d /lib ] || /bin/mkdir -p /lib

        for f in /tests/glibc/lib/ld-linux-*.so.*; do
            [ -f "$f" ] || continue
            base="${f##*/}"
            [ -e "/lib/$base" ] || /bin/ln -s "$f" "/lib/$base"
        done

        for base in libc.so.6 libm.so.6 libpthread.so.0 libdl.so.2 librt.so.1 libresolv.so.2; do
            if [ -f "/tests/glibc/lib/$base" ] && [ ! -e "/lib/$base" ]; then
                /bin/ln -s "/tests/glibc/lib/$base" "/lib/$base"
            fi
        done
    fi

    # Optional skip list: one token per line, e.g. "iozone-glibc" or "iozone-musl".
    # Blank lines and lines starting with '#' are ignored.
    #
    # This is useful to temporarily skip known-problematic test groups while keeping
    # the START/END markers for the judge log parser.
    OSCOMP_SKIP_FILE="/etc/oscomp_skip_tests"
    OSCOMP_CR="$(/bin/busybox printf '\r')"

    oscomp_group_tag_for_script() {
        # $1: full path to *_testcode.sh
        f="$1"
        base="${f##*/}"
        group="${base%_testcode.sh}"
        abi=""
        case "$f" in
            */glibc/*) abi="glibc" ;;
            */musl/*)  abi="musl" ;;
        esac
        if [ -n "$abi" ]; then
            echo "${group}-${abi}"
        else
            echo "${group}"
        fi
    }

    oscomp_should_skip_group() {
        # $1: group tag
        g="$1"
        [ -f "$OSCOMP_SKIP_FILE" ] || return 1
        g_base="${g%%-*}"
        while IFS= read -r line || [ -n "$line" ]; do
            # Trim CRLF + surrounding whitespace without external filters (avoid SIGPIPE noise).
            line="${line%$OSCOMP_CR}"
            # Strip leading whitespace
            line="${line#"${line%%[![:space:]]*}"}"
            # Strip trailing whitespace
            line="${line%"${line##*[![:space:]]}"}"
            case "$line" in
                ""|\#*) continue ;;
            esac
            [ "$line" = "$g" ] && return 0
            # Allow skipping the whole group regardless of ABI by writing just the base name.
            [ "$line" = "$g_base" ] && return 0
        done < "$OSCOMP_SKIP_FILE"
        return 1
    }

    scripts=""
    add_script() {
        # Cheap de-dup for pathological VFS behaviors (e.g., /tests exposing itself as /tests/tests).
        case " $scripts " in
            *" $1 "*) return 0 ;;
        esac
        scripts="$scripts $1"
    }

    # 1) Scripts directly under /tests.
    for f in /tests/*_testcode.sh; do
        [ -f "$f" ] || continue
        add_script "$f"
    done

    # 2) One-level deep: /tests/*/*. This matches the official images layout:
    #    /tests/glibc/*.sh and /tests/musl/*.sh.
    for d in /tests/*; do
        [ -d "$d" ] || continue
        # Avoid infinite recursion if the mount table/dentry cache accidentally exposes /tests as /tests/tests.
        [ "$d" = "/tests/tests" ] && continue
        for f in "$d"/*_testcode.sh; do
            [ -f "$f" ] || continue
            add_script "$f"
        done
    done
    [ -n "$scripts" ] || return 1

    echo "[OSCOMP] detected test scripts under /tests; running in rcS"
    export PATH="/bin:/sbin:/usr/bin:/usr/sbin:/tests"
    export HOME="/"

    for f in $scripts; do
        dir="${f%/*}"
        base="${f##*/}"
        group_tag="$(oscomp_group_tag_for_script "$f")"

        if oscomp_should_skip_group "$group_tag"; then
            echo "[OSCOMP] skipping $f (group=$group_tag)"
            bb="/bin/busybox"
            [ -x "$bb" ] || bb="/tests/glibc/busybox"
            [ -x "$bb" ] || bb="/tests/musl/busybox"
            "$bb" echo "#### OS COMP TEST GROUP START ${group_tag} ####"
            "$bb" echo "#### OS COMP TEST GROUP END ${group_tag} ####"
            continue
        fi

        echo "[OSCOMP] running $f"
        (
            cd "$dir" || exit 1
            # Use "." to avoid relying on kernel shebang/ENOEXEC behavior; avoid stdin blocking.
            . "./$base" </dev/null
        )
        rc=$?
        echo "[OSCOMP] finished $f (rc=$rc)"
    done

    echo "[OSCOMP] all tests finished; powering off"
    /sbin/poweroff -f || /sbin/reboot -f || true
    echo "[OSCOMP] poweroff returned unexpectedly; sleeping"
    while true; do sleep 3600; done
}

if run_oscomp_tests_if_present; then
    exit 0
fi

echo "rcS finished; spawning shell on ttyS0 via inittab"
exit 0
